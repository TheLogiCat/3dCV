### 基础变换
#### 平移
对每一个像素点坐标平移。可以让每一个像素点的x,y坐标都加一个变量。
矩阵表示：

![1761982071512](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982071512.png)

#### 放缩

进行放缩，就是将矩形（图像）放缩n倍，也就是长宽各乘一个变量。

![1761982121174](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982121174.png)

#### 旋转

![1761982138392](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982138392.png)

#### 错切

![img](https://pic4.zhimg.com/v2-cc1c2bc6eaa7abe900775b3022d09357_1440w.jpg)

矩阵表达：

![1761982173419](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982173419.png)

### 仿射变换

![1761982261319](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982261319.png)

![1761982210690](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982210690.png)

等式右边就是仿射变换矩阵，是由原图像平移，旋转，放缩，错切之后得来的。因此图片不论如何变化，线之间的平行性是不变的。

opencv中的仿射变换接口：

```python
warpAffine(
  InputArray  src,    输入图像
  OutputArray  dst,    输出图像
  InputArray  M,      仿射计算矩阵
  Size    dsize,    输出图像大小
  int      flags = INIET_LINEAR,   插值方法
  int      borderMode = BORDER_CONSTANT,   
  const Scalar&  borderValue = Scalar()  
  );
```

### 透视变换

![1761982251181](C:\Users\周啸晨\AppData\Roaming\Typora\typora-user-images\1761982251181.png)

仿射变换是将矩形变换成**平行四边形**（即变换后各边依旧平行），而透视变换可以变换成**任意不规则四边形**。可以说，仿射变换是透视变换的子集。

opencv中的透视变换接口：

```python
warpPerspective(
InputArray src,  输入图像
OutputArray dst,  输出图像
InputArray M,   输入透视变换矩阵M
Size dsize, 
int flags=INTER_LINEAR, 
int borderMode=BORDER_CONSTANT, 
const Scalar& borderValue=Scalar()
);
```

和仿射变换基本相同，不同的是输入透视变换矩阵M大小为3*3：

![img](https://pica.zhimg.com/v2-e8e51ca74ea39af69cf776a4a3c9d702_1440w.jpg)

T1为线性变换完成**旋转，错切和放缩**，T2完成**平移**操作。T3就是设了两个变量来表示**映射关系**。

上面矩阵的未知量比仿射变换的矩阵多了一个透视变换矩阵T3（两个未知量），因此我们需要给下面计算透视变换矩阵的函数提供四对以上的点来求解。